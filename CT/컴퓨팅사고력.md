# 컴퓨팅사고력



## 논리와 증명

**참고**

- 명제

  - 참이나 거짓을 알 수 있는 식이나 문장.
  - p, q, r 등으로 표현

- 진릿값

  - 참이나 거짓을 표현
  - T, F 또는 1, 0

  

- 연산 (결합)

  - 부정 NOT

    - p가 명제일 때, 명제의 진릿값이 반대

    - ~p (not p 또는 p의 부정으로 읽음)

      ![image-20220327170601068](%EC%BB%B4%ED%93%A8%ED%8C%85%EC%82%AC%EA%B3%A0%EB%A0%A5.assets/image-20220327170601068.png)

  - 논리곱 AND

    - p, q가 명제일 때, p, q 모두 참일 때만 참이 되는 명제.

    - p ^ q (p and q, p 그리고 q)

      ![image-20220327170654281](%EC%BB%B4%ED%93%A8%ED%8C%85%EC%82%AC%EA%B3%A0%EB%A0%A5.assets/image-20220327170654281.png)

  - 논리합 OR

    - p, q가 명제일 때, p, q 모두 거짓일 때만 거짓이 되는 명제.

    - p V q (p or q, p 또는 q)

      ![image-20220327170735249](%EC%BB%B4%ED%93%A8%ED%8C%85%EC%82%AC%EA%B3%A0%EB%A0%A5.assets/image-20220327170735249.png)

  - 배타적 논리합 XOR

    - p, q가 명제일 때, p, q 중 하나만 참일 때 참이 되는 명제.

      ![image-20220327170809472](%EC%BB%B4%ED%93%A8%ED%8C%85%EC%82%AC%EA%B3%A0%EB%A0%A5.assets/image-20220327170809472-16483756085581.png)



- 합성
  - 연산자 우선 순위
    - ~ > V, ^ > →, ↔
  - 항진명제 : 진릿값이 항상 참
  - 모순명제 : 진릿값이 항상 거짓
  - 사건명제 : 항진명제도 모순명제도 아닌 명제



- 조건명제

  - p, q가 명제일 때, 명제 p가 조건(또는 원인), q가 결론(또는 결과)로 제시되는 명제.

  - p → q (p이면 q이다.)

    ![image-20220327171102796](%EC%BB%B4%ED%93%A8%ED%8C%85%EC%82%AC%EA%B3%A0%EB%A0%A5.assets/image-20220327171102796.png)

- 쌍방조건명제

  - p, q가 명제일 때, 명제 p와 q가 모두 조건이면서 결론인 명제

  - p ↔ q (p면 q고, q면 p다.)

    ![image-20220327171303314](%EC%BB%B4%ED%93%A8%ED%8C%85%EC%82%AC%EA%B3%A0%EB%A0%A5.assets/image-20220327171303314.png)

- 조건명제의 역, 이, 대우

  - 역 : q → p

  - 이 : ~p → ~ q

  - 대우 : ~q → ~p

    ![image-20220327171404204](%EC%BB%B4%ED%93%A8%ED%8C%85%EC%82%AC%EA%B3%A0%EB%A0%A5.assets/image-20220327171404204.png)



## 수와 표현

**약간의 설명**

- 컴퓨터는 0/1을 표현할 수 있는 비트들을 모아 수를 표현

- k개의 비트를 사용하면 0부터 2^k-1까지 표현 가능

- 사실, 꼭 저 범위인 것은 아님. 약속하는 방식에 따라 다르지만, 어떤 경우든 최대 2^k 가지의 값을 표현하는 것이 가능

- 10진수로 k자리를 쓰면 0부터 10^k-1까지 표현이 가능한 것과 완전히 동일한 과정

  <img src="%EC%BB%B4%ED%93%A8%ED%8C%85%EC%82%AC%EA%B3%A0%EB%A0%A5.assets/image-20220327171707460.png" alt="image-20220327171707460" style="zoom:80%;" />

위의 사진에서, logn이란

- 2의 몇 승이 n이 되느냐에 대한 값
- n을 표현하는 데 몇 비트가 필요한가에 대한 값
- 1로 시작해서 계속 두 배를 할 때 몇 번 하면 n이 되느냐에 대한 답
- n을 계속 2로 나눌 때 몇 번 나누면 거의 1이 되드냐에 대한 답



**참고**

- x = log n 일 때 x와 n을 비교하면 x 가 더 작고, n 이 커질수록 값이 엄청나게 달라진다.
- 100자리로 표현할 수 있는 10진수 값을 읽을 수도 없을 정도로 큰 값이다.
- **컴퓨터 분야에서 로그의 밑은 항상 2**



![image-20220327171951941](%EC%BB%B4%ED%93%A8%ED%8C%85%EC%82%AC%EA%B3%A0%EB%A0%A5.assets/image-20220327171951941.png)



## 문제를 풀어보자

[참고링크](https://sangwoo0727.github.io/computational%20thinking/ComputationalThinking-2_2/)

### 1. 2진수 표현에서 logn 비트로 표현할 수 있는 숫자 범위는?

일반적으로 0 ~ 2^logn -1만큼의 수를 표현 할 수 있다.



### 2. 스무고개가 이상적으로 진행된다고 할 때, 맞출 수 있는 답의 종류는 몇 가지인가?

한번 질문 할 때마다, 답의 종류가 2가지이므로, 2^20가지의 답이 나올 수 있다.



### 3. n이 충분히 큰 값일 때 다음 중 어느 값이 더 큰가? 각 쌍에 대해 비교하고 그 이유를 작성하시오.

![image-20220327172232364](%EC%BB%B4%ED%93%A8%ED%8C%85%EC%82%AC%EA%B3%A0%EB%A0%A5.assets/image-20220327172232364.png)

1. y = 2n 은 n에 대한 1차 함수이고, y = n<sup>2</sup>은 n에 대한 2차 함수이므로, n > 2인 n에 대해서는 n<sup>2</sup>이 2n보다 항상 크다. (정답 : <)
2. y = 2<sup>n/2</sup>는 기울기 증가율이 1보다 크고, y = 루트3n (~~왜 루트 안 써져~~)은 기울기 증가율이 n이 커질수록 점점 감소하므로 (정답 : >)
3. (~~이제 수식 적기 질린다~~) 전자는 증가율이 지수그래프로 증가하는 것에 반해 후자는 그보다는 적게 증가하므로 (정답 : >)
4. y = nx 그래프에 n = 1, 2, 4, 8 / y = 1, 2, 4, 8 일 때 직접 그려보자 . (정답 : <) 





## 집합과 조합론

**집합과 조합론에 대한 약간의 설명**

- 두 집합 A와 B에 대해 A가 B의 부분집합임을 증명한다는 것은 A의 임의의 원소가 B에 포함됨을 보이는 것과 같다.
- 예를 들어 모든 4의 배수는 2의 배수라는 것을 증명하려면, 4k=2(2k) 임을 보이면 되는 것이다.
- 두 집합 A와 B가 같다는 것을 증명하기 위해서는 A가 B의 부분집합이고 B가 A의 부분집합임을 증명하면 된다.



- 조합론은 경우의 수를 따지는 문제들을 보통 말한다.

  ![image-20220327173824747](%EC%BB%B4%ED%93%A8%ED%8C%85%EC%82%AC%EA%B3%A0%EB%A0%A5.assets/image-20220327173824747.png)





## 기초 수식

**약간의 설명**

- 알고리즘의 시간 복잡도를 표현할 수 있는 다양한 수식들이 존재한다.
- 풀이법을 익혀 두어야 알고리즘의 시간 복잡도를 계산할 수 있고, 알고리즘이 시간이 얼마나 걸릴지 예측할 수 있다.



## 문제를 풀어보자

### 다음 재귀식들을 O() notation 수준으로 풀어라.

#### 문제 1

![image-20220327174052177](%EC%BB%B4%ED%93%A8%ED%8C%85%EC%82%AC%EA%B3%A0%EB%A0%A5.assets/image-20220327174052177.png)

<img src="%EC%BB%B4%ED%93%A8%ED%8C%85%EC%82%AC%EA%B3%A0%EB%A0%A5.assets/image-20220327175658894.png" alt="image-20220327175658894" style="zoom: 20%;" />

~~글씨가 부끄럽다~~



#### 문제2

![image-20220327175811812](%EC%BB%B4%ED%93%A8%ED%8C%85%EC%82%AC%EA%B3%A0%EB%A0%A5.assets/image-20220327175811812.png)

<img src="%EC%BB%B4%ED%93%A8%ED%8C%85%EC%82%AC%EA%B3%A0%EB%A0%A5.assets/image-20220327184104079.png" alt="image-20220327184104079" style="zoom:25%;" />





#### 문제3

![image-20220327184141286](%EC%BB%B4%ED%93%A8%ED%8C%85%EC%82%AC%EA%B3%A0%EB%A0%A5.assets/image-20220327184141286.png)

<img src="%EC%BB%B4%ED%93%A8%ED%8C%85%EC%82%AC%EA%B3%A0%EB%A0%A5.assets/image-20220327185848516.png" alt="image-20220327185848516" style="zoom:25%;" />



> 점근적 상한으로 풀어도 괜찮은 거야?
>
> n으로 표현할 수 있는 범위 안에서 가장 가까운 값을 표현한 건가..?
>
> 뭘 더 공부해야 이게 더 깔끔하게 이해가 될까?





## 재귀

**약간의 설명**

- 재귀란 자기 자신을 호출하는 함수.
- 함수는 입력이 있으며, 자기 자신의 입력과 동일한 입력으로 자기 자신을 호출하면 당연히 끝나지 않음.
- 하지만, 다른 입력으로 호출하면 끝날 수 있음



- 함수를 어떤 문제를 해결하는 방법을 코딩한 것
- 함수가 어떤 문제의 단 한 케이스만을 해결하는 것은 아님
- 제대로 코딩 된 것이라면 해결하는 문제의 모든 케이스들을 해결해야 함



![image-20220327190219599](%EC%BB%B4%ED%93%A8%ED%8C%85%EC%82%AC%EA%B3%A0%EB%A0%A5.assets/image-20220327190219599.png)





## 동적 프로그래밍

**약간의 설명**

- 재귀 함수에서 동일한 입력의 함수 호출이 반복적으로 일어날 때 그 결과값을 저장해 두고 불러 쓰는 것이다. (Memoization)
- 최초 입력에서 파생되는 모든 가능한 입력에 대한 답을 모두 저장할 수 있는 메모리가 있어야 한다.
- 단순히 재귀에서 저장된 값을 찾아보는 것으로도 가능하지만, 결과값을 순서를 정해서 계산할 수도 있다. (Dynamic Programming)

